function [DataX, DataY, windows_per_session] = Offline_DataPreprocess_Hanning_GuidanceAdaption(rawdata, classes, sample_frequency, WindowLength, SlideWindowLength, channels, subject_name, foldername, seconds_per_trial)    
    %% 采集参数
    %sample_frequency = 256; 
    
    %WindowLength = 512;  % 每个窗口的长度
    %SlideWindowLength = 256;  % 滑窗间隔
    
    Trigger = double(rawdata(end,:)); %rawdata最后一行
    % 关于channels，由于脑电帽子的部分电极的阻抗很不稳定，所以这里直接做channels的选择，注意目前设备的channels通道是1-32是通道数据，33是trigger的数据
    % 目前设置的channel选择为：
    % channels = [1,2,3,4,5,6,7,8,10,11,12,13,15,16,17,18,19,21,22,23,24,25,26,27,28,29,30];  
    % 选择的通道，这里去掉了OZ，M1,M2，Fp1，Fp2这几个channel
    
    DataX = [];
    DataY = [];  % 初始化整理的X和Y的数据
     
    for class_index = 0:(classes-1)
        RawDataMI = double(rawdata(channels, Trigger == class_index));  % 提取这一类的运动想象数据，并且提前做通道的选择，防止部分阻抗非常高的channel影响后面的CAR
        RawDataMI_CAR = ref_CAR(RawDataMI);  % CAR 处理
        FilteredDataMI = DataFilter(RawDataMI_CAR, sample_frequency);  % 滤波去噪
        [windows_per_session, winodws_num, SampleDataPre] = WindowsDataPre(FilteredDataMI, WindowLength, SlideWindowLength, sample_frequency, seconds_per_trial);
        [DataSample, LabelWindows] = DataWindows(SampleDataPre, FilteredDataMI, [], class_index, windows_per_session, SlideWindowLength, WindowLength, sample_frequency, winodws_num, seconds_per_trial);  % 划窗处理，注意这里不再做通道选择了
        DataX = [DataX; DataSample];
        DataY = [DataY, LabelWindows];
    end
    
    % 中途保存下要发送的数据 
    foldername = [foldername, '\\Offline_EEGMI_', subject_name]; % 指定文件夹路径和名称
    if ~exist(foldername, 'dir')
       mkdir(foldername);
    end
    % 预处理之后的数据存储，如果下面传输失败，直接将这两个mat文件送到服务器里
    save([foldername, '\\', FunctionNowFilename(['Offline_EEG_data_', subject_name], '.mat' )],'DataX');
    save([foldername, '\\', FunctionNowFilename(['Offline_EEG_label_', subject_name], '.mat' )],'DataY');
    
    %% Common Average Reference函数
    function DataRef = ref_CAR(RawData)
        % 参考了https://github.com/sccn/eeglab/blob/develop/functions/sigprocfunc/reref.m里面的写法
        nchan = size(RawData, 1);
        refmatrix = eye(nchan)-ones(nchan)*1/nchan;
        DataRef = refmatrix * RawData;
    end
    
    %% 滤波函数
    function FilteredData = DataFilter(RawData, sample_frequency) 
        FilterOrder = 4;  % 设置带通滤波器的阶数
        NotchFilterOrder = 2;  % 设置陷波滤波器的阶数（这里使用巴特沃斯带阻滤波器）
        % 这里的滤波器参数参考的是何晖光组里的几篇文献：
        % Ma X, Qiu S, He H. Multi-channel EEG recording during motor imagery of different joints from the same limb[J]. Scientific data, 2020, 7(1): 191.
        % Ma X, Qiu S, Wei W, et al. Deep channel-correlation network for motor imagery decoding from the same limb[J]. IEEE Transactions on Neural Systems and Rehabilitation Engineering, 2019, 28(1): 297-306.
        Wband = [0.1, 40];  % 滤波器这边需要参考相关的文献进行修改，这里参考佳星师姐的论文中的滤波器设置
        Wband_notch = [49,51];
        FilterType = 'bandpass';
        FilterTypeNotch = 'stop';  % matlab的butter函数里面，设置'stop'会自动设置成2阶滤波器

        % 使用陷波滤波器去除工频噪声
        FilteredData = Rsx_ButterFilter(NotchFilterOrder,Wband_notch,sample_frequency,FilterTypeNotch,RawData,size(RawData,1));
        % 使用带通滤波器去除噪声
        FilteredData = Rsx_ButterFilter(FilterOrder,Wband,sample_frequency,FilterType,FilteredData,size(FilteredData,1)); 
    end
    
    %% 计算划窗的函数
    function [windows_per_session, winodws_num, DataSamplePre] = WindowsDataPre(RawData, WindowLength, SlideWindowLength, sample_frequency, seconds_per_trial)
        
        trials_per_session = size(RawData,2)/(seconds_per_trial*sample_frequency);  % trial的数量
        winodws_num = (seconds_per_trial - (WindowLength/sample_frequency))/(SlideWindowLength/sample_frequency) + 1;  % 一个trial的滑窗的数量
        
        windows_per_session = trials_per_session * winodws_num;  % session滑窗后的窗数量

        % shape: (1, number of windows in this session)
        DataSamplePre = cell(1, windows_per_session);
    end

    %% 划窗函数
    function [DataSample, LabelWindows] = DataWindows(DataSamplePre, FilteredData, channels, class_index, windows_per_session, SlideWindowLength, WindowLength, sample_frequency, winodws_num, seconds_per_trial)
        % channels = [3:32]; 
        % channels = [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32]; 
        % channels = [3,8,27,28,30,31,32,33]-1;  % 确定前额叶的通道，由于记录的信号CH-1是Trigger，所以所有的索引减去1
        LabelWindows = [];
        % scores = [];  % 用于存储scores分数的数组

        % 生成划窗的数据
        for j = 1:(windows_per_session/winodws_num)
            for i = 1:winodws_num
                PointStart =(j-1)*sample_frequency*seconds_per_trial + (i-1)*SlideWindowLength;  % 在数据中确定起始点
                %DataSamplePre{1, winodws_num*(j-1)+i} = FilteredData(channels, PointStart + 1:PointStart + WindowLength );  % 生成划窗的元祖
                DataSamplePre{1, winodws_num*(j-1)+i} = FilteredData(1:end, PointStart + 1:PointStart + WindowLength );  % 生成划窗的元祖, 这里不再进行channel的选择，将提前进行channel的选择
                LabelWindows = [LabelWindows; class_index];  % 生成装label的数据
            end
        end
        DataSample = DataSamplePre;
    end
    %% 计算相关频带指标的函数
    function [EI_index, mu_power] = DataIndex(FilteredData, WindowLength, sample_frequency, channels)
        % 对滤波后的数据计算相关频带的能量指标
        k_ = WindowLength/sample_frequency;  % 由于使用的是离散傅里叶变换FFT，这里需要计算频率f和离散k之间的关系，参考DFT离散傅里叶变换的相关资料
        number_of_channels = size(channels, 2);
        alpha_band = [8:12]*k_;
        theta_band = [4:8]*k_;
        beta_band = [12:25]*k_;
        mu_band = [8:13]*k_; 
        DataPSD = FilteredData;
        E_beta = ones([1, number_of_channels]);
        E_alpha = ones([1, number_of_channels]);
        E_theta = ones([1, number_of_channels]);
        E_mu = ones([1, number_of_channels]);
        EI_ = ones([1, number_of_channels]); 
        
        % 计算傅里叶变换之后的信号的PSD图
        for i = 1:number_of_channels
            DataPSD(i,:) = abs(fft(FilteredData(i,:))).^2;  % 计算变换之后的频域幅值平方，用于计算能量，注意这里要对于每一个channel计算fft变换之后的频谱图
        end
        
        % 计算频带的相关指标
        for j = 1:number_of_channels
            E_beta(1,j) = sum(DataPSD(j,beta_band));
            E_alpha(1,j) = sum(DataPSD(j,alpha_band));
            E_theta(1,j) = sum(DataPSD(j,theta_band));
            E_mu(1,j) = sum(DataPSD(j,mu_band));
        end
        
        % 计算相关的指标数值
        for j = 1:number_of_channels
           EI_(1,j) = E_beta(1,j)/(E_alpha(1,j) + E_theta(1,j));  % EI指标的计算 
        end
        % 返回每一个channel对应的EI指标和mu频带的能量
        EI_index = EI_;
        mu_power = E_mu;  
    end
end